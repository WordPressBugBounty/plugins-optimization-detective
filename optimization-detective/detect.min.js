const win=window,doc=win.document,consoleLogPrefix="[Optimization Detective]",storageLockTimeSessionKey="odStorageLockTime";function isStorageLocked(e,t){if(0===t)return!1;try{const o=parseInt(sessionStorage.getItem("odStorageLockTime"));return!isNaN(o)&&e<o+1e3*t}catch(e){return!1}}function setStorageLock(e){try{sessionStorage.setItem("odStorageLockTime",String(e))}catch(e){}}function log(...e){console.log(consoleLogPrefix,...e)}function warn(...e){console.warn(consoleLogPrefix,...e)}function error(...e){console.error(consoleLogPrefix,...e)}function isViewportNeeded(e,t){let o=!1;for(const{minimumViewportWidth:n,complete:r}of t){if(!(e>=n))break;o=!r}return o}function getCurrentTime(){return Date.now()}function recursiveFreeze(e){for(const t of Object.getOwnPropertyNames(e)){const o=e[t];null!==o&&"object"==typeof o&&recursiveFreeze(o)}Object.freeze(e)}let urlMetric;const reservedRootPropertyKeys=new Set(["url","viewport","elements"]);function getRootData(){const e=structuredClone(urlMetric);return recursiveFreeze(e),e}function extendRootData(e){for(const t of Object.getOwnPropertyNames(e))if(reservedRootPropertyKeys.has(t))throw new Error(`Disallowed setting of key '${t}' on root.`);Object.assign(urlMetric,e)}const elementsByXPath=new Map,reservedElementPropertyKeys=new Set(["isLCP","isLCPCandidate","xpath","intersectionRatio","intersectionRect","boundingClientRect"]);function getElementData(e){const t=elementsByXPath.get(e);if(t){const e=structuredClone(t);return recursiveFreeze(e),e}return null}function extendElementData(e,t){if(!elementsByXPath.has(e))throw new Error(`Unknown element with XPath: ${e}`);for(const e of Object.getOwnPropertyNames(t))if(reservedElementPropertyKeys.has(e))throw new Error(`Disallowed setting of key '${e}' on element.`);const o=elementsByXPath.get(e);Object.assign(o,t)}export default async function detect({minViewportAspectRatio:e,maxViewportAspectRatio:t,isDebug:o,extensionModuleUrls:n,restApiEndpoint:r,currentETag:i,currentUrl:s,urlMetricSlug:a,cachePurgePostId:c,urlMetricHMAC:l,urlMetricGroupStatuses:d,storageLockTTL:u,webVitalsLibrarySrc:g,urlMetricGroupCollection:f}){if(o){const e=[];for(const t of f.groups)for(const o of t.url_metrics)o.creationDate=new Date(1e3*o.timestamp),e.push(o);log("Stored URL Metric Group Collection:",f),e.sort(((e,t)=>t.timestamp-e.timestamp)),log("Stored URL Metrics in reverse chronological order:",e)}if(!isViewportNeeded(win.innerWidth,d))return void(o&&log("No need for URL Metrics from the current viewport."));const p=win.innerWidth/win.innerHeight;if(p<e||p>t)return void(o&&warn(`Viewport aspect ratio (${p}) is not in the accepted range of ${e} to ${t}.`));if(await new Promise((e=>{"loading"!==doc.readyState?e():doc.addEventListener("DOMContentLoaded",e,{once:!0})})),await new Promise((e=>{"complete"===doc.readyState?e():win.addEventListener("load",e,{once:!0})})),"function"==typeof requestIdleCallback&&await new Promise((e=>{requestIdleCallback(e)})),isStorageLocked(getCurrentTime(),u))return void(o&&warn("Aborted detection due to storage being locked."));let w=!1;window.addEventListener("resize",(()=>{w=!0}),{once:!0});const{onTTFB:m,onFCP:h,onLCP:P,onINP:L,onCLS:y}=await import(g);if(doc.documentElement.scrollTop>0)return void(o&&warn("Aborted detection since initial scroll position of page is not at the top."));o&&log("Proceeding with detection");const v=new Map,b=[],S=[];for(const e of n)try{const t=await import(e);if(v.set(e,t),t.initialize instanceof Function){const n=t.initialize({isDebug:o,onTTFB:m,onFCP:h,onLCP:P,onINP:L,onCLS:y});n instanceof Promise&&(b.push(n),S.push(e))}}catch(t){error(`Failed to start initializing extension '${e}':`,t)}const C=await Promise.allSettled(b);for(const[e,t]of C.entries())"rejected"===t.status&&error(`Failed to initialize extension '${S[e]}':`,t.reason);const R=doc.body.querySelectorAll("[data-od-xpath]"),M=new Map([...R].map((e=>[e,e.dataset.odXpath]))),D=[];let E;function x(){E instanceof IntersectionObserver&&(E.disconnect(),win.removeEventListener("scroll",x))}M.size>0&&(await new Promise((e=>{E=new IntersectionObserver((t=>{for(const e of t)D.push(e);e()}),{root:null,threshold:0});for(const e of M.keys())E.observe(e)})),win.addEventListener("scroll",x,{once:!0,passive:!0}));const k=[];await new Promise((e=>{P((t=>{k.push(t),e()}),{reportAllChanges:!0})})),x(),o&&log("Detection is stopping."),urlMetric={url:s,viewport:{width:win.innerWidth,height:win.innerHeight},elements:[]};const z=k.at(-1);for(const e of D){const t=M.get(e.target);if(!t){o&&error("Unable to look up XPath for element");continue}const n=z?.entries[0]?.element,r={isLCP:e.target===n,isLCPCandidate:!!k.find((t=>{const o=t.entries[0]?.element;return o===e.target})),xpath:t,intersectionRatio:e.intersectionRatio,intersectionRect:e.intersectionRect,boundingClientRect:e.boundingClientRect};urlMetric.elements.push(r),elementsByXPath.set(r.xpath,r)}if(o&&log("Current URL Metric:",urlMetric),await new Promise((e=>{win.addEventListener("pagehide",e,{once:!0}),win.addEventListener("pageswap",e,{once:!0}),doc.addEventListener("visibilitychange",(()=>{"hidden"===document.visibilityState&&e()}),{once:!0})})),w)return void(o&&log("Aborting URL Metric collection due to viewport size change."));if(v.size>0){const e=[],t=[];for(const[n,r]of v.entries())if(r.finalize instanceof Function)try{const i=r.finalize({isDebug:o,getRootData,getElementData,extendElementData,extendRootData});i instanceof Promise&&(e.push(i),t.push(n))}catch(e){error(`Unable to start finalizing extension '${n}':`,e)}const n=await Promise.allSettled(e);for(const[e,o]of n.entries())"rejected"===o.status&&error(`Failed to finalize extension '${t[e]}':`,o.reason)}setStorageLock(getCurrentTime()),o&&log("Sending URL Metric:",urlMetric);const T=new URL(r);T.searchParams.set("slug",a),T.searchParams.set("current_etag",i),"number"==typeof c&&T.searchParams.set("cache_purge_post_id",c.toString()),T.searchParams.set("hmac",l),navigator.sendBeacon(T,new Blob([JSON.stringify(urlMetric)],{type:"application/json"})),M.clear()}